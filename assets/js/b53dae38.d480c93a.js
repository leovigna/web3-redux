"use strict";(self.webpackChunk_owlprotocol_web3_redux_docs=self.webpackChunk_owlprotocol_web3_redux_docs||[]).push([[512],{9613:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return m}});var r=n(9496);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function c(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?c(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):c(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},c=Object.keys(e);for(r=0;r<c.length;r++)n=c[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var c=Object.getOwnPropertySymbols(e);for(r=0;r<c.length;r++)n=c[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),s=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=s(e.components);return r.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,c=e.originalType,l=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),p=s(n),m=a,y=p["".concat(l,".").concat(m)]||p[m]||d[m]||c;return n?r.createElement(y,o(o({ref:t},u),{},{components:n})):r.createElement(y,o({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var c=n.length,o=new Array(c);o[0]=p;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:a,o[1]=i;for(var s=2;s<c;s++)o[s]=n[s];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},1169:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return i},contentTitle:function(){return l},metadata:function(){return s},toc:function(){return u},default:function(){return p}});var r=n(7813),a=n(7044),c=(n(9496),n(9613)),o=["components"],i={},l=void 0,s={unversionedId:"web3-redux-advanced/index",id:"web3-redux-advanced/index",title:"index",description:"Advanced",source:"@site/docs/web3-redux-advanced/index.md",sourceDirName:"web3-redux-advanced",slug:"/web3-redux-advanced/",permalink:"/web3-redux/docs/web3-redux-advanced/",editUrl:"https://github.com/owlprotocol/web3-redux/tree/master/docusaurus/docs/web3-redux-advanced/index.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"metamask",permalink:"/web3-redux/docs/web3-redux-integrations/metamask"},next:{title:"Initialize the Redux Store",permalink:"/web3-redux/docs/web3-redux-advanced/custom_store"}},u=[{value:"Advanced",id:"advanced",children:[{value:"Optimizing Contract Call Sync",id:"optimizing-contract-call-sync",children:[],level:3},{value:"Custom Contract Call Sync",id:"custom-contract-call-sync",children:[],level:3}],level:2}],d={toc:u};function p(e){var t=e.components,n=(0,a.Z)(e,o);return(0,c.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,c.kt)("h2",{id:"advanced"},"Advanced"),(0,c.kt)("h3",{id:"optimizing-contract-call-sync"},"Optimizing Contract Call Sync"),(0,c.kt)("p",null,"By default, contracts use Transaction syncing but this can be customized for each specific contract call. This is can be a sub-optimal or even incorrect sync strategy."),(0,c.kt)("p",null,"Transaction syncing can be sub-optimal if a call's return value never changes. For example, an ERC19 token's name or symbol. In this case simply disable syncing with ",(0,c.kt)("inlineCode",{parentName:"p"},"sync: false"),"."),(0,c.kt)("p",null,"Transaction syncing assumes that the contract call values are only dependent on your contract's state and that this state is only changed by direct transactions to your contract. The basic logic for Transaction syncing is as follows: For each transaction in a new block, update contract call if ",(0,c.kt)("inlineCode",{parentName:"p"},"tx.to == contract.address"),".\nExamples of cases where this assumption might be incorrect include:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},"Contract call return value depends on block number"),(0,c.kt)("li",{parentName:"ul"},"Contract state can be changed by a call to some proxy contract")),(0,c.kt)("p",null,"In these cases we recommend switching to Block syncing, which will poll the contract call at every block. For even better optimization, it might be interesting in some cases to use a custom block or transaction sync."),(0,c.kt)("h3",{id:"custom-contract-call-sync"},"Custom Contract Call Sync"),(0,c.kt)("p",null,"The interface of ContractCallBlockSync and ContractCallTransactionSync use a filter function returning whether a contract call should update. Customizing the filter function can help you create more optimized syncing depending on your use case."),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-typescript"},"export interface ContractCallBlockSync {\n    type: typeof CALL_BLOCK_SYNC;\n    filter: (block: BlockHeader) => boolean;\n}\n\nexport interface ContractCallTransactionSync {\n    type: typeof CALL_TRANSACTION_SYNC;\n    filter: (transaction: Transaction) => boolean;\n}\n")),(0,c.kt)("p",null,"Example sync strategies:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},"Sync every 4 blocks: ",(0,c.kt)("inlineCode",{parentName:"li"},"(block) => block.number % 5 == 0")),(0,c.kt)("li",{parentName:"ul"},"Sync for transactions to contract or proxy: ",(0,c.kt)("inlineCode",{parentName:"li"},"(tx) => tx.to === contract.address || tx.to === proxy.address"))))}p.isMDXComponent=!0}}]);